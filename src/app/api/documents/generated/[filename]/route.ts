import { NextRequest, NextResponse } from 'next/server';
import { withSimpleAuth } from '@/lib/middleware/simple-auth';

/**
 * GET /api/documents/generated/[filename]
 * Serve generated documents with authentication
 */
export const GET = withSimpleAuth(async (request: NextRequest, user, { params }) => {
  try {
    const filename = params.filename as string;

    if (!filename) {
      return NextResponse.json(
        {
          error: 'Missing filename',
          message: 'Filename is required'
        },
        { status: 400 }
      );
    }

    // Validate filename format and extract document info
    const fileExtension = filename.split('.').pop()?.toLowerCase();
    const supportedFormats = ['pdf', 'docx', 'html', 'xlsx'];

    if (!fileExtension || !supportedFormats.includes(fileExtension)) {
      return NextResponse.json(
        {
          error: 'Invalid file format',
          message: 'File format not supported'
        },
        { status: 400 }
      );
    }

    // In production, this would:
    // 1. Verify user has permission to access this document
    // 2. Fetch document from S3 or file storage
    // 3. Stream the document content

    // Mock document serving
    const mockDocumentResponse = () => {
      const mimeTypes = {
        pdf: 'application/pdf',
        docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        html: 'text/html',
        xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      };

      const mimeType = mimeTypes[fileExtension as keyof typeof mimeTypes];

      // Generate mock content
      let content: string;
      if (fileExtension === 'html') {
        content = `
          <!DOCTYPE html>
          <html>
            <head>
              <title>Generated Document</title>
              <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .header { text-align: center; margin-bottom: 30px; }
                .content { line-height: 1.6; }
                .footer { margin-top: 30px; text-align: center; font-size: 12px; color: #666; }
              </style>
            </head>
            <body>
              <div class="header">
                <h1>Generated Document</h1>
                <p>File: ${filename}</p>
                <p>Generated on: ${new Date().toLocaleString()}</p>
              </div>
              <div class="content">
                <h2>Document Content</h2>
                <p>This is a mock generated document. In production, this would contain the actual document content generated from the template with real data.</p>
                <p>Generated for user: ${user.firstName} ${user.lastName}</p>
                <p>User ID: ${user.id}</p>
                <p>Generation timestamp: ${new Date().toISOString()}</p>
              </div>
              <div class="footer">
                <p>Generated by PROP.ie Enterprise Document System</p>
              </div>
            </body>
          </html>
        `;
      } else {
        content = `Mock ${fileExtension.toUpperCase()} content for ${filename}`;
      }

      return new NextResponse(content, {
        status: 200,
        headers: {
          'Content-Type': mimeType,
          'Content-Disposition': `inline; filename="${filename}"`,
          'Cache-Control': 'private, max-age=3600',
          'X-Generated-By': 'PROP.ie Document Engine',
          'X-Generated-At': new Date().toISOString()
        }
      });
    };

    // Log document access for audit trail
    console.log(`Document accessed: ${filename} by user ${user.id} at ${new Date().toISOString()}`);

    return mockDocumentResponse();

    /* In production, implement actual document serving:
    
    // Verify document exists and user has access
    const document = await prisma.document.findFirst({
      where: {
        fileUrl: { endsWith: filename },
        OR: [
          { uploadedById: user.id },
          { project: { developerId: user.id } },
          // Add other permission checks
        ]
      }
    });

    if (!document) {
      return NextResponse.json(
        { error: 'Document not found or access denied' },
        { status: 404 }
      );
    }

    // Fetch from S3 or file storage
    const documentBuffer = await fetchDocumentFromStorage(document.fileUrl);
    
    return new NextResponse(documentBuffer, {
      status: 200,
      headers: {
        'Content-Type': document.mimeType,
        'Content-Disposition': `inline; filename="${document.name}"`,
        'Content-Length': String(documentBuffer.length),
        'Cache-Control': 'private, max-age=3600'
      }
    });
    */

  } catch (error: any) {
    console.error('Document serving error:', error);
    return NextResponse.json(
      {
        error: 'Failed to serve document',
        message: error.message
      },
      { status: 500 }
    );
  }
}, {
  requiredRoles: ['DEVELOPER', 'PROJECT_MANAGER', 'ARCHITECT', 'ADMIN']
});