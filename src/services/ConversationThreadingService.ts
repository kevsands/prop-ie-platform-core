/**
 * ================================================================================
 * CONVERSATION THREADING AND MANAGEMENT SERVICE
 * Advanced message threading, conversation organization, and relationship management
 * ================================================================================
 */

import { EventEmitter } from 'events';

// Core Types
export interface MessageThread {
  id: string;
  parentMessageId?: string;
  rootMessageId?: string;
  conversationId: string;
  level: number; // 0 = root message, 1 = direct reply, 2+ = nested replies
  threadPath: string[]; // Array of message IDs leading to this message
  replies: MessageThread[];
  messageId: string;
  createdAt: Date;
  updatedAt: Date;
  isActive: boolean;
  metadata: Record<string, any>;
}

export interface ConversationContext {
  id: string;
  conversationId: string;
  contextType: 'property_purchase' | 'htb_application' | 'legal_support' | 'mortgage_application' | 'general_inquiry' | 'task_related' | 'payment_related';
  entityId?: string; // Property ID, Task ID, etc.
  entityType?: string;
  title: string;
  description?: string;
  tags: string[];
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status: 'active' | 'resolved' | 'archived' | 'escalated';
  assignedTo?: string[];
  watchers: string[];
  createdAt: Date;
  updatedAt: Date;
  resolvedAt?: Date;
  resolvedBy?: string;
  resolution?: string;
  metadata: Record<string, any>;
}

export interface ConversationSummary {
  id: string;
  conversationId: string;
  participantCount: number;
  messageCount: number;
  threadCount: number;
  unreadCount: number;
  lastActivity: Date;
  mostActiveParticipant: {
    userId: string;
    messageCount: number;
  };
  commonTopics: string[];
  sentiment: 'positive' | 'neutral' | 'negative' | 'mixed';
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical';
  autoGeneratedAt: Date;
  summary: string;
  keyPoints: string[];
  actionItems: {
    id: string;
    description: string;
    assignedTo?: string;
    dueDate?: Date;
    status: 'pending' | 'in_progress' | 'completed';
  }[];
}

export interface ConversationSearch {
  query: string;
  filters: {
    conversationIds?: string[];
    participantIds?: string[];
    messageTypes?: string[];
    dateRange?: {
      from: Date;
      to: Date;
    };
    contextTypes?: string[];
    hasAttachments?: boolean;
    priority?: string;
    status?: string;
    tags?: string[];
  };
  sorting: {
    field: 'relevance' | 'date' | 'priority' | 'participants';
    direction: 'asc' | 'desc';
  };
  pagination: {
    limit: number;
    offset: number;
  };
}

export interface ConversationAnalytics {
  conversationId: string;
  period: {
    from: Date;
    to: Date;
  };
  metrics: {
    totalMessages: number;
    totalThreads: number;
    averageResponseTime: number; // in minutes
    participantEngagement: {
      userId: string;
      messageCount: number;
      averageResponseTime: number;
      lastActive: Date;
    }[];
    busyTimes: {
      hour: number;
      messageCount: number;
    }[];
    topTopics: {
      topic: string;
      count: number;
    }[];
    resolutionTime?: number; // in hours
    escalationCount: number;
  };
  trends: {
    messageVolumeTrend: 'increasing' | 'decreasing' | 'stable';
    responseTrend: 'improving' | 'declining' | 'stable';
    participationTrend: 'increasing' | 'decreasing' | 'stable';
  };
}

// Events
export const THREADING_EVENTS = {
  THREAD_CREATED: 'threading:thread_created',
  THREAD_UPDATED: 'threading:thread_updated',
  CONTEXT_CREATED: 'threading:context_created',
  CONTEXT_UPDATED: 'threading:context_updated',
  CONVERSATION_SUMMARIZED: 'threading:conversation_summarized',
  ACTION_ITEM_CREATED: 'threading:action_item_created',
  SEARCH_PERFORMED: 'threading:search_performed'
} as const;

/**
 * Conversation Threading Service Class
 * Manages message threading, conversation context, and advanced organization
 */
export class ConversationThreadingService extends EventEmitter {
  private threads: Map<string, MessageThread> = new Map();
  private contexts: Map<string, ConversationContext> = new Map();
  private summaries: Map<string, ConversationSummary> = new Map();
  private analytics: Map<string, ConversationAnalytics> = new Map();

  constructor() {
    super();
    this.setupEventHandlers();
    this.initializeDefaultContexts();
  }

  private setupEventHandlers() {
    this.on(THREADING_EVENTS.THREAD_CREATED, this.handleThreadCreated.bind(this));
    this.on(THREADING_EVENTS.CONTEXT_UPDATED, this.handleContextUpdated.bind(this));
  }

  private initializeDefaultContexts() {
    // Initialize default conversation contexts
    const defaultContexts = [
      {
        contextType: 'property_purchase' as const,
        title: 'Property Purchase Process',
        description: 'All discussions related to property purchasing',
        tags: ['property', 'purchase', 'legal', 'financial'],
        priority: 'high' as const
      },
      {
        contextType: 'htb_application' as const,
        title: 'Help-to-Buy Applications',
        description: 'Help-to-Buy scheme applications and support',
        tags: ['htb', 'government', 'benefits', 'financial'],
        priority: 'medium' as const
      },
      {
        contextType: 'legal_support' as const,
        title: 'Legal Support',
        description: 'Legal advice and contract reviews',
        tags: ['legal', 'contracts', 'solicitor', 'advice'],
        priority: 'high' as const
      }
    ];

    defaultContexts.forEach((context, index) => {
      this.createContext({
        conversationId: `default_${index}`,
        ...context,
        assignedTo: [],
        watchers: [],
        status: 'active',
        metadata: { isDefault: true }
      });
    });
  }

  /**
   * Create a new message thread
   */
  async createThread(params: {
    messageId: string;
    conversationId: string;
    parentMessageId?: string;
    metadata?: Record<string, any>;
  }): Promise<MessageThread> {
    const { messageId, conversationId, parentMessageId, metadata = {} } = params;

    let level = 0;
    let rootMessageId = messageId;
    let threadPath: string[] = [messageId];

    if (parentMessageId) {
      const parentThread = this.threads.get(parentMessageId);
      if (parentThread) {
        level = parentThread.level + 1;
        rootMessageId = parentThread.rootMessageId || parentThread.messageId;
        threadPath = [...parentThread.threadPath, messageId];
      }
    }

    const thread: MessageThread = {
      id: this.generateId('thread'),
      parentMessageId,
      rootMessageId,
      conversationId,
      level,
      threadPath,
      replies: [],
      messageId,
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true,
      metadata
    };

    this.threads.set(thread.id, thread);

    // Update parent thread's replies
    if (parentMessageId) {
      const parentThread = this.threads.get(parentMessageId);
      if (parentThread) {
        parentThread.replies.push(thread);
        parentThread.updatedAt = new Date();
        this.threads.set(parentMessageId, parentThread);
      }
    }

    this.emit(THREADING_EVENTS.THREAD_CREATED, thread);

    return thread;
  }

  /**
   * Get thread structure for a conversation
   */
  getConversationThreads(conversationId: string): MessageThread[] {
    const conversationThreads = Array.from(this.threads.values())
      .filter(thread => thread.conversationId === conversationId)
      .sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());

    // Build hierarchical structure
    const rootThreads = conversationThreads.filter(thread => !thread.parentMessageId);
    
    const buildThreadHierarchy = (thread: MessageThread): MessageThread => {
      const replies = conversationThreads
        .filter(t => t.parentMessageId === thread.messageId)
        .map(reply => buildThreadHierarchy(reply));
      
      return {
        ...thread,
        replies: replies.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime())
      };
    };

    return rootThreads.map(buildThreadHierarchy);
  }

  /**
   * Create conversation context
   */
  async createContext(params: {
    conversationId: string;
    contextType: ConversationContext['contextType'];
    entityId?: string;
    entityType?: string;
    title: string;
    description?: string;
    tags?: string[];
    priority?: ConversationContext['priority'];
    assignedTo?: string[];
    watchers?: string[];
    metadata?: Record<string, any>;
  }): Promise<ConversationContext> {
    const context: ConversationContext = {
      id: this.generateId('context'),
      conversationId: params.conversationId,
      contextType: params.contextType,
      entityId: params.entityId,
      entityType: params.entityType,
      title: params.title,
      description: params.description,
      tags: params.tags || [],
      priority: params.priority || 'medium',
      status: 'active',
      assignedTo: params.assignedTo || [],
      watchers: params.watchers || [],
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: params.metadata || {}
    };

    this.contexts.set(context.id, context);
    this.emit(THREADING_EVENTS.CONTEXT_CREATED, context);

    return context;
  }

  /**
   * Update conversation context
   */
  async updateContext(contextId: string, updates: Partial<ConversationContext>): Promise<ConversationContext> {
    const context = this.contexts.get(contextId);
    if (!context) {
      throw new Error('Context not found');
    }

    const updatedContext = {
      ...context,
      ...updates,
      updatedAt: new Date()
    };

    this.contexts.set(contextId, updatedContext);
    this.emit(THREADING_EVENTS.CONTEXT_UPDATED, updatedContext);

    return updatedContext;
  }

  /**
   * Generate conversation summary
   */
  async generateSummary(conversationId: string): Promise<ConversationSummary> {
    const threads = this.getConversationThreads(conversationId);
    const context = Array.from(this.contexts.values())
      .find(ctx => ctx.conversationId === conversationId);

    // Simulate message analysis (in real implementation, this would analyze actual messages)
    const mockMessageData = {
      participantCount: 4,
      messageCount: 15,
      threadCount: threads.length,
      unreadCount: 3,
      lastActivity: new Date(),
      mostActiveParticipant: {
        userId: 'user_solicitor_001',
        messageCount: 6
      },
      commonTopics: ['contract review', 'completion timeline', 'final inspection'],
      sentiment: 'positive' as const
    };

    // Generate AI-powered summary (simulated)
    const summary: ConversationSummary = {
      id: this.generateId('summary'),
      conversationId,
      ...mockMessageData,
      urgencyLevel: context?.priority === 'high' ? 'high' : 'medium',
      autoGeneratedAt: new Date(),
      summary: 'Property purchase progressing well. Contract review completed with minor queries about timeline. Final inspection scheduled for next week.',
      keyPoints: [
        'Contract review completed by solicitor',
        'Minor queries raised about completion timeline',
        'Final inspection scheduled for next Tuesday',
        'Help-to-Buy benefit approved (€30,000)',
        'Mortgage approved for €280,000'
      ],
      actionItems: [
        {
          id: this.generateId('action'),
          description: 'Confirm availability for final inspection next Tuesday',
          assignedTo: 'current_user',
          dueDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
          status: 'pending'
        },
        {
          id: this.generateId('action'),
          description: 'Schedule call to discuss completion timeline queries',
          assignedTo: 'user_solicitor_001',
          dueDate: new Date(Date.now() + 1 * 24 * 60 * 60 * 1000),
          status: 'pending'
        }
      ]
    };

    this.summaries.set(summary.id, summary);
    this.emit(THREADING_EVENTS.CONVERSATION_SUMMARIZED, summary);

    return summary;
  }

  /**
   * Search conversations with advanced filtering
   */
  async searchConversations(searchParams: ConversationSearch): Promise<{
    results: any[];
    totalCount: number;
    facets: {
      contextTypes: { [key: string]: number };
      participants: { [key: string]: number };
      timeRanges: { [key: string]: number };
    };
  }> {
    const { query, filters, sorting, pagination } = searchParams;

    // In a real implementation, this would query the database with full-text search
    // For now, simulate search results
    const mockResults = [
      {
        conversationId: 'conv_001',
        title: 'Fitzgerald Gardens Unit 12A - Purchase',
        snippet: 'Contract review completed. Minor queries about completion timeline...',
        relevanceScore: 0.95,
        lastActivity: new Date(Date.now() - 2 * 60 * 60 * 1000),
        participantCount: 4,
        messageCount: 15,
        contextType: 'property_purchase',
        tags: ['property', 'purchase', 'legal'],
        highlightedTerms: query.split(' ').filter(term => term.length > 2)
      },
      {
        conversationId: 'conv_002',
        title: 'Help-to-Buy Application Support',
        snippet: 'HTB application successfully submitted to Revenue. Benefit approved...',
        relevanceScore: 0.78,
        lastActivity: new Date(Date.now() - 24 * 60 * 60 * 1000),
        participantCount: 2,
        messageCount: 8,
        contextType: 'htb_application',
        tags: ['htb', 'government', 'benefits'],
        highlightedTerms: []
      }
    ];

    // Apply filters (simulated)
    let filteredResults = mockResults;

    if (filters.contextTypes?.length) {
      filteredResults = filteredResults.filter(result => 
        filters.contextTypes!.includes(result.contextType)
      );
    }

    if (filters.dateRange) {
      filteredResults = filteredResults.filter(result => 
        result.lastActivity >= filters.dateRange!.from && 
        result.lastActivity <= filters.dateRange!.to
      );
    }

    // Apply sorting
    filteredResults.sort((a, b) => {
      switch (sorting.field) {
        case 'relevance':
          return sorting.direction === 'desc' ? b.relevanceScore - a.relevanceScore : a.relevanceScore - b.relevanceScore;
        case 'date':
          return sorting.direction === 'desc' ? 
            b.lastActivity.getTime() - a.lastActivity.getTime() : 
            a.lastActivity.getTime() - b.lastActivity.getTime();
        default:
          return 0;
      }
    });

    // Apply pagination
    const startIndex = pagination.offset;
    const endIndex = startIndex + pagination.limit;
    const paginatedResults = filteredResults.slice(startIndex, endIndex);

    // Generate facets
    const facets = {
      contextTypes: {
        'property_purchase': 1,
        'htb_application': 1,
        'legal_support': 0
      },
      participants: {
        '2-3': 1,
        '4-5': 1,
        '6+': 0
      },
      timeRanges: {
        'today': 1,
        'this_week': 2,
        'this_month': 2
      }
    };

    this.emit(THREADING_EVENTS.SEARCH_PERFORMED, {
      query,
      resultCount: paginatedResults.length,
      totalCount: filteredResults.length
    });

    return {
      results: paginatedResults,
      totalCount: filteredResults.length,
      facets
    };
  }

  /**
   * Generate conversation analytics
   */
  async generateAnalytics(conversationId: string, period: { from: Date; to: Date }): Promise<ConversationAnalytics> {
    // In real implementation, this would analyze actual message data
    const analytics: ConversationAnalytics = {
      conversationId,
      period,
      metrics: {
        totalMessages: 15,
        totalThreads: 3,
        averageResponseTime: 45, // minutes
        participantEngagement: [
          {
            userId: 'user_solicitor_001',
            messageCount: 6,
            averageResponseTime: 30,
            lastActive: new Date(Date.now() - 2 * 60 * 60 * 1000)
          },
          {
            userId: 'current_user',
            messageCount: 5,
            averageResponseTime: 60,
            lastActive: new Date(Date.now() - 30 * 60 * 1000)
          },
          {
            userId: 'user_developer_001',
            messageCount: 2,
            averageResponseTime: 120,
            lastActive: new Date(Date.now() - 4 * 60 * 60 * 1000)
          },
          {
            userId: 'user_agent_001',
            messageCount: 2,
            averageResponseTime: 90,
            lastActive: new Date(Date.now() - 1 * 60 * 60 * 1000)
          }
        ],
        busyTimes: [
          { hour: 9, messageCount: 3 },
          { hour: 14, messageCount: 4 },
          { hour: 16, messageCount: 5 },
          { hour: 18, messageCount: 3 }
        ],
        topTopics: [
          { topic: 'contract review', count: 8 },
          { topic: 'timeline', count: 5 },
          { topic: 'inspection', count: 4 },
          { topic: 'help-to-buy', count: 3 }
        ],
        resolutionTime: 72, // hours
        escalationCount: 0
      },
      trends: {
        messageVolumeTrend: 'stable',
        responseTrend: 'improving',
        participationTrend: 'increasing'
      }
    };

    this.analytics.set(conversationId, analytics);

    return analytics;
  }

  /**
   * Get conversation context
   */
  getConversationContext(conversationId: string): ConversationContext | null {
    return Array.from(this.contexts.values())
      .find(context => context.conversationId === conversationId) || null;
  }

  /**
   * Get conversation summary
   */
  getConversationSummary(conversationId: string): ConversationSummary | null {
    return Array.from(this.summaries.values())
      .find(summary => summary.conversationId === conversationId) || null;
  }

  /**
   * Get conversation analytics
   */
  getConversationAnalytics(conversationId: string): ConversationAnalytics | null {
    return this.analytics.get(conversationId) || null;
  }

  /**
   * Create action item from conversation
   */
  async createActionItem(params: {
    conversationId: string;
    description: string;
    assignedTo?: string;
    dueDate?: Date;
    priority?: 'low' | 'medium' | 'high';
    metadata?: Record<string, any>;
  }): Promise<ConversationSummary['actionItems'][0]> {
    const actionItem = {
      id: this.generateId('action'),
      description: params.description,
      assignedTo: params.assignedTo,
      dueDate: params.dueDate,
      status: 'pending' as const
    };

    // Update conversation summary with new action item
    const summary = this.getConversationSummary(params.conversationId);
    if (summary) {
      summary.actionItems.push(actionItem);
      this.summaries.set(summary.id, summary);
    }

    this.emit(THREADING_EVENTS.ACTION_ITEM_CREATED, { conversationId: params.conversationId, actionItem });

    return actionItem;
  }

  /**
   * Archive conversation
   */
  async archiveConversation(conversationId: string, reason?: string): Promise<void> {
    const context = this.getConversationContext(conversationId);
    if (context) {
      await this.updateContext(context.id, {
        status: 'archived',
        resolvedAt: new Date(),
        resolution: reason
      });
    }

    // Mark all threads as inactive
    Array.from(this.threads.values())
      .filter(thread => thread.conversationId === conversationId)
      .forEach(thread => {
        thread.isActive = false;
        thread.updatedAt = new Date();
        this.threads.set(thread.id, thread);
      });
  }

  // Event handlers
  private async handleThreadCreated(thread: MessageThread): Promise<void> {
    console.log(`Thread created: ${thread.id} (Level ${thread.level})`);
    
    // Auto-update conversation summary when new threads are created
    setTimeout(() => {
      this.generateSummary(thread.conversationId);
    }, 1000);
  }

  private async handleContextUpdated(context: ConversationContext): Promise<void> {
    console.log(`Context updated: ${context.id} - Status: ${context.status}`);
  }

  // Utility methods
  private generateId(prefix: string = 'id'): string {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Export singleton instance
export const conversationThreadingService = new ConversationThreadingService();