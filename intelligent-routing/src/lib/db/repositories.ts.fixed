import { query, transaction } from './connection';
import { userDb } from './operations/userDb';
import { developmentDb } from './operations/developmentDb';
import { unitDb } from './operations/unitDb';
import * as mappers from './mappers';
import { userCache, developmentCache, unitCache, salesCache, documentCache, financeCache } from './cache';
import { logger } from '../security/auditLogger';
import {
  User,
  Development,
  Unit,
  Sale,
  Document,
  DevelopmentFinance,
  Budget,
  CashFlow,
  CustomizationOption,
  CustomizationSelection,
  Transaction,
  PaginatedResult,
  DevelopmentFilter,
  UnitFilter,
  SaleFilter,
  DocumentFilter,
  TransactionFilter
} from './types';

// Import repositories to re-export
import { 
  UserRepository as PrismaUserRepository,
  DevelopmentRepository as PrismaDevelopmentRepository,
  UnitRepository as PrismaUnitRepository,
  DocumentRepository,
  FinancialRepository
} from './repositories';

/**
 * Repository pattern implementation for PropIE AWS database
 * Provides type-safe, domain-specific database access with caching
 */

/**
 * Base repository class with common CRUD operations
 */
abstract class BaseRepository<T> {
  protected abstract tableName: string;
  protected abstract cacheNamespace: string;
  protected abstract mapToEntity(dbRecord: any): T;
  protected abstract mapToDatabaseRecord(entity: T): any;
  
  /**
   * Find entity by ID
   * @param id Entity ID
   * @returns Entity or null if not found
   */
  async findById(id: string): Promise<T | null> {
    // Check cache first
    const cacheKey = `${this.cacheNamespace}:id:${id}`;
    let cache: any;
    
    switch (this.cacheNamespace) {
      case 'users': cache = userCache; break;
      case 'developments': cache = developmentCache; break;
      case 'units': cache = unitCache; break;
      case 'sales': cache = salesCache; break;
      case 'documents': cache = documentCache; break;
      case 'finance': cache = financeCache; break;
      default: cache = null;
    }
    
    if (cache) {
      const cached = cache.get<T>(cacheKey, []);
      if (cached) {
        return cached;
      }
    }
    
    try {
      const result = await query(`SELECT * FROM ${this.tableName} WHERE id = $1`, [id]);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      const entity = this.mapToEntity(result.rows[0]);
      
      // Store in cache
      if (cache) {
        cache.set(cacheKey, [], entity);
      }
      
      return entity;
    } catch (error) {
      logger.error(`Error finding ${this.tableName} by ID`, { error, id });
      throw error;
    }
  }
  
  /**
   * Find all entities with optional pagination
   * @param page Page number (1-based)
   * @param pageSize Number of items per page
   * @returns Paginated result with entities
   */
  async findAll(page: number = 1, pageSize: number = 20): Promise<PaginatedResult<T>> {
    try {
      // Get total count
      const countResult = await query(`SELECT COUNT(*) FROM ${this.tableName}`);
      const total = parseInt(countResult.rows[0].count);
      
      // Calculate pagination
      const offset = (page - 1) * pageSize;
      const totalPages = Math.ceil(total / pageSize);
      
      // Get entities
      const result = await query(
        `SELECT * FROM ${this.tableName} ORDER BY created_at DESC LIMIT $1 OFFSET $2`,
        [pageSize, offset]
      );
      
      const items = result.rows.map(row => this.mapToEntity(row));
      
      return {
        items,
        total,
        page,
        pageSize,
        totalPages
      };
    } catch (error) {
      logger.error(`Error finding all ${this.tableName}`, { error, page, pageSize });
      throw error;
    }
  }
  
  /**
   * Create a new entity
   * @param entity Entity to create
   * @returns Created entity
   */
  async create(entity: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T> {
    try {
      const dbRecord = this.mapToDatabaseRecord(entity as T);
      
      // Remove id, createdAt, and updatedAt as they will be generated by the database
      delete dbRecord.id;
      delete dbRecord.created_at;
      delete dbRecord.updated_at;
      
      // Build query
      const keys = Object.keys(dbRecord);
      const values = Object.values(dbRecord);
      const placeholders = keys.map((_, index) => `$${index + 1}`).join(', ');
      const columns = keys.join(', ');
      
      const result = await query(
        `INSERT INTO ${this.tableName} (${columns}) VALUES (${placeholders}) RETURNING *`,
        values
      );
      
      return this.mapToEntity(result.rows[0]);
    } catch (error) {
      logger.error(`Error creating ${this.tableName}`, { error, entity });
      throw error;
    }
  }
  
  /**
   * Update an entity
   * @param id Entity ID
   * @param entity Entity data to update
   * @returns Updated entity
   */
  async update(id: string, entity: Partial<T>): Promise<T> {
    try {
      const dbRecord = this.mapToDatabaseRecord(entity as T);
      
      // Remove id, createdAt, and updatedAt as they should not be updated
      delete dbRecord.id;
      delete dbRecord.created_at;
      delete dbRecord.updated_at;
      
      // Build query
      const keys = Object.keys(dbRecord);
      const values = Object.values(dbRecord);
      
      if (keys.length === 0) {
        // Nothing to update
        const currentEntity = await this.findById(id);
        return currentEntity as T;
      }
      
      const setClause = keys.map((key, index) => `${key} = $${index + 2}`).join(', ');
      
      const result = await query(
        `UPDATE ${this.tableName} SET ${setClause} WHERE id = $1 RETURNING *`,
        [id, ...values]
      );
      
      // Invalidate cache
      this.invalidateCache(id);
      
      return this.mapToEntity(result.rows[0]);
    } catch (error) {
      logger.error(`Error updating ${this.tableName}`, { error, id, entity });
      throw error;
    }
  }
  
  /**
   * Delete an entity
   * @param id Entity ID
   * @returns True if entity was deleted, false if not found
   */
  async delete(id: string): Promise<boolean> {
    try {
      const result = await query(`DELETE FROM ${this.tableName} WHERE id = $1 RETURNING id`, [id]);
      
      // Invalidate cache
      this.invalidateCache(id);
      
      return result.rows.length > 0;
    } catch (error) {
      logger.error(`Error deleting ${this.tableName}`, { error, id });
      throw error;
    }
  }
  
  /**
   * Invalidate cache for an entity
   * @param id Entity ID
   */
  protected invalidateCache(id: string): void {
    let cache: any;
    
    switch (this.cacheNamespace) {
      case 'users': cache = userCache; break;
      case 'developments': cache = developmentCache; break;
      case 'units': cache = unitCache; break;
      case 'sales': cache = salesCache; break;
      case 'documents': cache = documentCache; break;
      case 'finance': cache = financeCache; break;
      default: return;
    }
    
    if (cache) {
      const cacheKey = `${this.cacheNamespace}:id:${id}`;
      cache.invalidate(cacheKey, []);
    }
  }
}

/**
 * User repository for managing user data
 */
class UserRepository extends BaseRepository<User> {
  protected tableName = 'users';
  protected cacheNamespace = 'users';
  
  /**
   * Map database user record to User entity
   * @param dbRecord Database user record
   * @returns User entity
   */
  protected mapToEntity(dbRecord: any): User {
    return mappers.mapUser(dbRecord);
  }
  
  /**
   * Map User entity to database record
   * @param user User entity
   * @returns Database user record
   */
  protected mapToDatabaseRecord(user: User): any {
    return mappers.mapUserToDb(user);
  }
  
  /**
   * Find user by email
   * @param email User email
   * @returns User or null if not found
   */
  async findByEmail(email: string): Promise<User | null> {
    const cacheKey = `${this.cacheNamespace}:email:${email}`;
    const cached = userCache.get<User>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const dbUser = await userDb.getByEmail(email);
      
      if (!dbUser) {
        return null;
      }
      
      const user = this.mapToEntity(dbUser);
      
      // Store in cache
      userCache.set(cacheKey, [], user);
      
      return user;
    } catch (error) {
      logger.error('Error finding user by email', { error, email });
      throw error;
    }
  }
  
  /**
   * Get user permissions
   * @param userId User ID
   * @returns Array of permission names
   */
  async getUserPermissions(userId: string): Promise<string[]> {
    const cacheKey = `${this.cacheNamespace}:permissions:${userId}`;
    const cached = userCache.get<string[]>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const permissions = await userDb.getPermissions(userId);
      
      // Store in cache
      userCache.set(cacheKey, [], permissions);
      
      return permissions;
    } catch (error) {
      logger.error('Error getting user permissions', { error, userId });
      throw error;
    }
  }
  
  /**
   * Invalidate user permissions cache
   * @param userId User ID
   */
  invalidatePermissionsCache(userId: string): void {
    const cacheKey = `${this.cacheNamespace}:permissions:${userId}`;
    userCache.invalidate(cacheKey, []);
  }
}

/**
 * Development repository for managing development data
 */
class DevelopmentRepository extends BaseRepository<Development> {
  protected tableName = 'developments';
  protected cacheNamespace = 'developments';
  
  /**
   * Map database development record to Development entity
   * @param dbRecord Database development record
   * @returns Development entity
   */
  protected mapToEntity(dbRecord: any): Development {
    return mappers.mapDevelopment(dbRecord);
  }
  
  /**
   * Map Development entity to database record
   * @param development Development entity
   * @returns Database development record
   */
  protected mapToDatabaseRecord(development: Development): any {
    return mappers.mapDevelopmentToDb(development);
  }
  
  /**
   * Find developments with filtering
   * @param filters Development filters
   * @param page Page number (1-based)
   * @param pageSize Number of items per page
   * @returns Paginated result with developments
   */
  async findByFilters(filters: DevelopmentFilter, page: number = 1, pageSize: number = 20): Promise<PaginatedResult<Development>> {
    try {
      const filteredDevelopments = await developmentDb.getAll(filters, pageSize, (page - 1) * pageSize);
      
      // Get total count with the same filters
      const countQuery = await query(
        'SELECT COUNT(*) FROM developments WHERE developer_id = $1 OR status = $2 OR name ILIKE $3',
        [
          filters.developerId || '', 
          filters.status || '', 
          filters.name ? `%${filters.name}%` : ''
        ]
      );
      
      const total = parseInt(countQuery.rows[0].count);
      const totalPages = Math.ceil(total / pageSize);
      
      const developments = filteredDevelopments.map(dev => this.mapToEntity(dev));
      
      return {
        items: developments,
        total,
        page,
        pageSize,
        totalPages
      };
    } catch (error) {
      logger.error('Error finding developments by filters', { error, filters });
      throw error;
    }
  }
  
  /**
   * Find developments by developer ID
   * @param developerId Developer user ID
   * @returns Array of developments
   */
  async findByDeveloperId(developerId: string): Promise<Development[]> {
    const cacheKey = `${this.cacheNamespace}:developer:${developerId}`;
    const cached = developmentCache.get<Development[]>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const developments = await developmentDb.getAll({ developerId });
      
      const mappedDevelopments = developments.map(dev => this.mapToEntity(dev));
      
      // Store in cache
      developmentCache.set(cacheKey, [], mappedDevelopments);
      
      return mappedDevelopments;
    } catch (error) {
      logger.error('Error finding developments by developer ID', { error, developerId });
      throw error;
    }
  }
  
  /**
   * Get development timelines
   * @param developmentId Development ID
   * @returns Array of timeline objects
   */
  async getTimelines(developmentId: string): Promise<any[]> {
    const cacheKey = `${this.cacheNamespace}:timelines:${developmentId}`;
    const cached = developmentCache.get<any[]>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const timelines = await developmentDb.getTimelines(developmentId);
      
      // Store in cache
      developmentCache.set(cacheKey, [], timelines);
      
      return timelines;
    } catch (error) {
      logger.error('Error getting development timelines', { error, developmentId });
      throw error;
    }
  }
}

/**
 * Unit repository for managing unit data
 */
class UnitRepository extends BaseRepository<Unit> {
  protected tableName = 'units';
  protected cacheNamespace = 'units';
  
  /**
   * Map database unit record to Unit entity
   * @param dbRecord Database unit record
   * @returns Unit entity
   */
  protected mapToEntity(dbRecord: any): Unit {
    return mappers.mapUnit(dbRecord);
  }
  
  /**
   * Map Unit entity to database record
   * @param unit Unit entity
   * @returns Database unit record
   */
  protected mapToDatabaseRecord(unit: Unit): any {
    return mappers.mapUnitToDb(unit);
  }
  
  /**
   * Find units by development ID
   * @param developmentId Development ID
   * @param filters Unit filters
   * @returns Array of units
   */
  async findByDevelopment(developmentId: string, filters?: UnitFilter): Promise<Unit[]> {
    const filterKey = JSON.stringify(filters || {});
    const cacheKey = `${this.cacheNamespace}:development:${developmentId}:${filterKey}`;
    const cached = unitCache.get<Unit[]>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const units = await unitDb.getByDevelopment(developmentId, filters);
      
      const mappedUnits = units.map(unit => this.mapToEntity(unit));
      
      // Store in cache
      unitCache.set(cacheKey, [], mappedUnits);
      
      return mappedUnits;
    } catch (error) {
      logger.error('Error finding units by development ID', { error, developmentId, filters });
      throw error;
    }
  }
  
  /**
   * Get rooms for a unit
   * @param unitId Unit ID
   * @returns Array of room objects
   */
  async getRooms(unitId: string): Promise<any[]> {
    const cacheKey = `${this.cacheNamespace}:rooms:${unitId}`;
    const cached = unitCache.get<any[]>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const rooms = await unitDb.getRooms(unitId);
      
      // Store in cache
      unitCache.set(cacheKey, [], rooms);
      
      return rooms;
    } catch (error) {
      logger.error('Error getting unit rooms', { error, unitId });
      throw error;
    }
  }
  
  /**
   * Get customization options for a unit
   * @param unitId Unit ID
   * @param categoryFilter Optional category filter
   * @returns Array of customization options
   */
  async getCustomizationOptions(unitId: string, categoryFilter?: string): Promise<CustomizationOption[]> {
    const cacheKey = `${this.cacheNamespace}:customization:${unitId}:${categoryFilter || 'all'}`;
    const cached = unitCache.get<CustomizationOption[]>(cacheKey, []);
    
    if (cached) {
      return cached;
    }
    
    try {
      const options = await unitDb.getCustomizationOptions(unitId, categoryFilter);
      
      const mappedOptions = options.map(option => mappers.mapCustomizationOption(option));
      
      // Store in cache
      unitCache.set(cacheKey, [], mappedOptions);
      
      return mappedOptions;
    } catch (error) {
      logger.error('Error getting customization options', { error, unitId, categoryFilter });
      throw error;
    }
  }
}

// Create singleton instances
export const userRepository = new UserRepository();
export const developmentRepository = new DevelopmentRepository();
export const unitRepository = new UnitRepository();
export const documentRepository = new DocumentRepository();
export const financialRepository = new FinancialRepository();

// Re-export the base repository
export { BaseRepository };

// Export repository classes with their SQL implementations
export { 
  UserRepository,
  DevelopmentRepository,
  UnitRepository,
  DocumentRepository,
  FinancialRepository
};

// Re-export Prisma-based repositories for tests
export {
  PrismaUserRepository,
  PrismaDevelopmentRepository,
  PrismaUnitRepository
};

// Export default with all repository instances
export default {
  userRepository,
  developmentRepository,
  unitRepository,
  documentRepository,
  financialRepository
};