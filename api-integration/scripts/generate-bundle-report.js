/**
 * Bundle Analysis Report Generator
 * 
 * This script analyzes the bundle stats generated by @next/bundle-analyzer
 * and creates a detailed report with recommendations for optimization.
 */

const fs = require('fs');
const path = require('path');

// Constants for analysis
const LARGE_CHUNK_SIZE = 100 * 1024; // 100KB
const VERY_LARGE_CHUNK_SIZE = 250 * 1024; // 250KB
const CRITICAL_CHUNK_SIZE = 500 * 1024; // 500KB
const RECOMMENDED_MAX_INITIAL_SIZE = 200 * 1024; // 200KB for first load

// Format byte size to human-readable format
function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' bytes';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

// Main analysis function
async function analyzeBundle() {
  try {
    console.log('Reading build stats...');
    
    // Try to locate the client stats file
    let statsFile;
    const possiblePaths = [
      path.join(process.cwd(), '.next', 'analyze', 'client.json'),
      path.join(process.cwd(), '.next', 'stats', 'client.json'),
      // Add more potential paths if needed
    ];
    
    for (const filePath of possiblePaths) {
      if (fs.existsSync(filePath)) {
        statsFile = filePath;
        break;
      }
    }
    
    if (!statsFile) {
      throw new Error('Could not find build stats file. Make sure you ran ANALYZE=true npm run build');
    }
    
    // Read and parse stats
    const stats = JSON.parse(fs.readFileSync(statsFile, 'utf8'));
    
    // Filter assets (JavaScript chunks)
    const jsAssets = stats.assets.filter(asset => 
      asset.name.endsWith('.js') && 
      !asset.name.includes('webpack-runtime') &&
      !asset.name.includes('polyfills')
    );
    
    // Sort by size (descending)
    const sortedAssets = [...jsAssets].sort((a, b) => b.size - a.size);
    
    // Calculate total bundle size
    const totalJsSize = jsAssets.reduce((sum, asset) => sum + asset.size, 0);
    
    // Identify initial load chunks (main chunks that load immediately)
    const initialChunks = jsAssets.filter(asset => 
      asset.name.includes('main') || 
      asset.name.includes('pages/index') ||
      asset.name.includes('pages/_app') ||
      asset.name.includes('framework') ||
      asset.name.includes('commons') ||
      // For App Router, look for these patterns
      asset.name.includes('app/page') ||
      asset.name.includes('app/layout')
    );
    
    const initialLoadSize = initialChunks.reduce((sum, asset) => sum + asset.size, 0);
    
    // Identify potentially problematic chunks
    const largeChunks = sortedAssets.filter(asset => asset.size > LARGE_CHUNK_SIZE);
    const veryLargeChunks = sortedAssets.filter(asset => asset.size > VERY_LARGE_CHUNK_SIZE);
    const criticalChunks = sortedAssets.filter(asset => asset.size > CRITICAL_CHUNK_SIZE);
    
    // Identify duplicate modules
    let duplicates = [];
    if (stats.modules) {
      const modulesByName = {};
      stats.modules.forEach(module => {
        if (!modulesByName[module.name]) {
          modulesByName[module.name] = [];
        }
        modulesByName[module.name].push(module);
      });
      
      // Find modules that appear more than once
      duplicates = Object.entries(modulesByName)
        .filter(([name, modules]) => modules.length > 1)
        .map(([name, modules]) => ({
          name,
          count: modules.length,
          totalSize: modules.reduce((sum, m) => sum + (m.size || 0), 0)
        }))
        .sort((a, b) => b.totalSize - a.totalSize)
        .slice(0, 10); // Top 10 duplicates
    }
    
    // Generate recommendations
    const recommendations = [];
    
    // Initial load size recommendations
    if (initialLoadSize > RECOMMENDED_MAX_INITIAL_SIZE * 2) {
      recommendations.push({
        severity: 'critical',
        message: `Initial load size is ${formatSize(initialLoadSize)}, which is significantly larger than recommended (${formatSize(RECOMMENDED_MAX_INITIAL_SIZE)}).`,
        solution: 'Consider deferring non-critical JavaScript with dynamic imports and lazy loading.'
      });
    } else if (initialLoadSize > RECOMMENDED_MAX_INITIAL_SIZE) {
      recommendations.push({
        severity: 'warning',
        message: `Initial load size is ${formatSize(initialLoadSize)}, which is larger than recommended (${formatSize(RECOMMENDED_MAX_INITIAL_SIZE)}).`,
        solution: 'Consider optimizing initial load with better code splitting.'
      });
    }
    
    // Critical chunks recommendations
    if (criticalChunks.length > 0) {
      recommendations.push({
        severity: 'critical',
        message: `There ${criticalChunks.length === 1 ? 'is' : 'are'} ${criticalChunks.length} extremely large chunk${criticalChunks.length === 1 ? '' : 's'} (>500KB).`,
        solution: 'These chunks should be split into smaller pieces with code splitting.',
        items: criticalChunks.map(chunk => `${chunk.name} (${formatSize(chunk.size)})`)
      });
    }
    
    // Very large chunks recommendations
    if (veryLargeChunks.length > 3) {
      recommendations.push({
        severity: 'warning',
        message: `There are ${veryLargeChunks.length} very large chunks (>250KB).`,
        solution: 'Consider using dynamic imports to split these chunks further.',
        items: veryLargeChunks.slice(0, 5).map(chunk => `${chunk.name} (${formatSize(chunk.size)})`)
      });
    }
    
    // Duplicate modules recommendations
    if (duplicates.length > 0 && duplicates[0].totalSize > 50 * 1024) {
      recommendations.push({
        severity: 'warning',
        message: 'There are significant duplicate modules in the bundle.',
        solution: 'Check package resolutions and webpack configuration to ensure modules are properly deduped.',
        items: duplicates.slice(0, 3).map(dup => `${dup.name} (${dup.count} copies, ${formatSize(dup.totalSize)})`)
      });
    }
    
    // Check for legacy polyfills
    const polyfillsChunk = stats.assets.find(asset => asset.name.includes('polyfills'));
    if (polyfillsChunk && polyfillsChunk.size > 50 * 1024) {
      recommendations.push({
        severity: 'info',
        message: `Polyfills chunk is ${formatSize(polyfillsChunk.size)}.`,
        solution: 'Consider using the "browserslist" field in package.json to narrow down supported browsers and reduce polyfills.'
      });
    }
    
    // Generate the full report
    const report = {
      summary: {
        totalBundleSize: formatSize(totalJsSize),
        initialLoadSize: formatSize(initialLoadSize),
        totalChunks: jsAssets.length,
        largeChunks: largeChunks.length,
        veryLargeChunks: veryLargeChunks.length,
        criticalChunks: criticalChunks.length
      },
      topChunks: sortedAssets.slice(0, 10).map(asset => ({
        name: asset.name,
        size: formatSize(asset.size),
        sizeBytes: asset.size
      })),
      initialLoadChunks: initialChunks.map(asset => ({
        name: asset.name,
        size: formatSize(asset.size),
        sizeBytes: asset.size
      })),
      recommendations,
      generatedAt: new Date().toISOString()
    };
    
    // Save the report
    fs.writeFileSync('bundle-report.json', JSON.stringify(report, null, 2));
    
    console.log('Bundle report generated successfully!');
    console.log(`Total Bundle Size: ${formatSize(totalJsSize)}`);
    console.log(`Initial Load Size: ${formatSize(initialLoadSize)}`);
    console.log(`Critical Recommendations: ${recommendations.filter(r => r.severity === 'critical').length}`);
    
  } catch (error) {
    console.error('Error generating bundle report:', error);
  }
}

// Run the analysis
analyzeBundle().catch(console.error);